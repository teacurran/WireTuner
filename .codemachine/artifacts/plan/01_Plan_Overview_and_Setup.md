# Project Plan: WireTuner Vector Drawing Application

**Version:** 1.0
**Date:** 2025-11-05
**Generated By:** Claude Sonnet 4.5

---

<!-- anchor: project-overview -->
## 1. Project Overview

<!-- anchor: project-goal -->
*   **Goal:** Build a professional, event-sourced vector drawing application for macOS/Windows using Flutter, delivering a working editor with pen tool, shape creation (rectangle, ellipse, polygon, star), anchor/BCP manipulation, and save/load functionality within ~21 days.

<!-- anchor: high-level-requirements -->
*   **High-Level Requirements Summary:**
    *   Event-sourced architecture with 50ms sampling rate for all user interactions
    *   SQLite-based persistence with .wiretuner file format
    *   Flutter CustomPainter rendering engine targeting 60 FPS
    *   Core vector editing tools: Pen (straight/Bezier), Selection, Direct Selection
    *   Shape creation tools: Rectangle, Ellipse, Polygon, Star
    *   Direct manipulation: drag objects, anchor points, and Bezier control points
    *   Immutable domain models (Path, Shape, Document)
    *   Snapshot system (every 1000 events) for performance optimization
    *   File operations: save/load .wiretuner documents with version compatibility
    *   Import/Export: Adobe Illustrator import, SVG/PDF export
    *   Support documents with 10,000+ objects without degradation

<!-- anchor: key-assumptions -->
*   **Key Assumptions:**
    *   Single developer with Flutter/Dart expertise, ~8 hours/day focused development
    *   Desktop-first focus (macOS 10.15+, Windows 10 1809+), mobile platforms deferred
    *   Single-user workflows (collaborative features architecturally supported but not implemented)
    *   SQLite provides adequate performance for event log persistence
    *   Flutter desktop is stable enough for production use (3.16+)
    *   50ms sampling rate provides sufficient fidelity without overwhelming storage
    *   Snapshots every 1000 events balance memory usage with replay speed
    *   Expected file sizes remain manageable (< 100MB typical, < 500MB maximum)
    *   Dissipate prototype provides architectural reference but no code reuse
    *   Test coverage target: 80%+ for core logic (models, services)

---

<!-- anchor: core-architecture -->
## 2. Core Architecture

<!-- anchor: architectural-style -->
*   **Architectural Style:** Event-Sourced Layered Architecture
    *   **Event Sourcing Foundation:** All state changes captured as immutable events in append-only log, enabling infinite undo/redo, audit trail, and future collaboration support
    *   **Layered Structure:**
        ```
        Presentation Layer (UI/Widgets) → Flutter widgets, tools, canvas
        Application Layer (Use Cases)   → Event handlers, tool controllers
        Domain Layer (Models & Logic)   → Path, Shape, Document models
        Infrastructure Layer (Persistence) → SQLite, file I/O, event store
        ```

<!-- anchor: technology-stack -->
*   **Technology Stack:**
    *   **Frontend:** Flutter 3.16+ widgets with CustomPainter for canvas rendering
    *   **Backend:** Dart 3.2+ (null-safe, strong typing)
    *   **Runtime:** Native compilation for macOS/Windows desktop
    *   **Database:** SQLite via `sqflite_common_ffi` package (embedded, ACID-compliant)
    *   **State Management:** Provider 6.0+ for UI reactivity
    *   **Event Sourcing:** Custom implementation (EventRecorder, EventReplayer, SnapshotManager)
    *   **Rendering:** dart:ui Canvas API, vector_math for transforms
    *   **Import/Export:**
        *   `xml` package for SVG import/export
        *   `pdf` package for PDF export
        *   Custom parser + `pdf` for Adobe Illustrator (.ai) import
    *   **Deployment:**
        *   macOS: .dmg installer (notarized)
        *   Windows: .exe installer (MSIX or Inno Setup, code-signed)
    *   **CI/CD:** GitHub Actions for automated builds and testing
    *   **Testing:**
        *   `test` package for unit tests
        *   `flutter_test` for widget tests
        *   `integration_test` for end-to-end tests
    *   **Other Key Libraries/Tools:**
        *   `freezed` (optional) for immutable model code generation
        *   `logger` for logging with file output
        *   Dart analyzer with strict linting rules

<!-- anchor: key-components -->
*   **Key Components/Services:**
    *   **UI Layer:** Main window, toolbars, tool panels, canvas widget, dialogs
    *   **Canvas Renderer:** CustomPainter implementation for 60 FPS vector rendering with viewport transforms
    *   **Tool System:** Abstract ITool interface with implementations (Pen, Selection, Direct Selection, Rectangle, Ellipse, Polygon, Star)
    *   **Event Sourcing Core:**
        *   EventRecorder: Samples user input at 50ms, creates event objects
        *   EventReplayer: Reconstructs document state from event log
        *   SnapshotManager: Creates/loads state snapshots every 1000 events
    *   **Vector Engine:** Domain models (Document, Path, Shape, Segment, AnchorPoint, Style, Transform)
    *   **Geometry Engine:** Bezier math, hit testing, bounds calculation, path operations
    *   **Persistence Layer:**
        *   Event Store: SQLite table with append-only event log
        *   Snapshot Store: SQLite BLOB storage for serialized document snapshots
    *   **Import/Export Services:**
        *   SVG Exporter: Converts Document to SVG 1.1 XML
        *   PDF Exporter: Generates PDF 1.7 documents
        *   AI Importer: Parses Adobe Illustrator files (PDF-based)
        *   SVG Importer: Parses SVG into Document events
    *   *Refer to Component Diagram (see Iteration 1, Task 2) for detailed visualization*

<!-- anchor: data-model-overview -->
*   **Data Model Overview:**
    *   **Persistent Schema (SQLite):**
        *   `metadata` table: document_id (PK), title, format_version, created_at, modified_at
        *   `events` table: event_id (PK), document_id (FK), event_sequence, event_type, event_payload (JSON), timestamp
        *   `snapshots` table: snapshot_id (PK), document_id (FK), event_sequence, snapshot_data (BLOB), created_at, compression
    *   **Domain Model (In-Memory, Immutable):**
        *   **Document:** Root container with layers, objects, selection, viewport
        *   **Layer:** Named container with visibility, lock state, and list of VectorObjects
        *   **VectorObject (abstract):** Base for Path and Shape, with id, transform, style
        *   **Path:** Sequence of Segments (line, Bezier, arc), open or closed
        *   **Shape:** Parametric definitions (Rectangle, Ellipse, Polygon, Star) with toPath() method
        *   **Segment:** Connects two AnchorPoints, may include Bezier control points
        *   **AnchorPoint:** Position + optional in/out handles (BCPs), anchor type (corner/smooth/symmetric)
        *   **Style:** Fill, stroke, opacity, blend mode properties
        *   **Transform:** Affine transformation matrix (translate, rotate, scale)
        *   **Selection:** Set of object IDs and anchor indices
    *   *Refer to ERD diagrams (see Iteration 2, Task 4) for complete schema*

<!-- anchor: api-contract-style -->
*   **API Contract Style:**
    *   **Internal APIs Only** (no REST/GraphQL): Desktop application with in-process communication
    *   **Event-Driven Pattern:** Tools emit events → EventRecorder → Event Store → EventDispatcher → Event Handlers → Updated Document State
    *   **Synchronous Request/Response:** Direct method calls for document queries (getObjectById, getAllObjects)
    *   **Publish/Subscribe (UI):** Provider-based reactivity (ChangeNotifier → notifyListeners() → Consumer widgets rebuild)

<!-- anchor: communication-patterns -->
*   **Communication Patterns:**
    *   **Event Flow:** User Input → Tool Controller → EventRecorder (50ms sampling) → SQLite Event Log → EventDispatcher → Event Handlers → New Document State → UI Rebuild
    *   **Document Replay:** SQLite Event Log → EventReplayer (loads snapshot + replays events) → Reconstructed Document → Canvas Renderer
    *   **Undo/Redo:** Event Navigator navigates to target event sequence → EventReplayer reconstructs state at that point
    *   *Refer to Sequence Diagrams (see Iteration 1, Task 3) for detailed interaction flows*

---

<!-- anchor: key-artifacts-planned -->
## 2.1. Key Architectural Artifacts Planned

<!-- anchor: artifact-list -->
*   **Component Diagram (PlantUML)** - Visualize major service interactions and dependencies
    *   Purpose: Clarify boundaries between UI, Event Core, Vector Engine, and Persistence layers
    *   Format: PlantUML C4 Component Diagram
    *   Created in: Iteration 1, Task 2

*   **Event Sourcing Sequence Diagrams (PlantUML)** - Show critical event flows
    *   Purpose: Document interaction patterns for pen tool usage, document loading, undo/redo, dragging operations
    *   Format: PlantUML Sequence Diagrams (5 diagrams)
    *   Created in: Iteration 1, Task 3

*   **Database ERD (PlantUML)** - Show SQLite schema for event log and snapshots
    *   Purpose: Define persistent data structure for .wiretuner files
    *   Format: PlantUML Entity-Relationship Diagram
    *   Created in: Iteration 2, Task 4

*   **Domain Model Class Diagram (PlantUML)** - Visualize in-memory object relationships
    *   Purpose: Document immutable data structures for Document, Path, Shape, etc.
    *   Format: PlantUML Class Diagram
    *   Created in: Iteration 2, Task 5

*   **Event Schema Definitions (Dart sealed classes)** - Type-safe event definitions
    *   Purpose: Define event types (CreatePath, AddAnchor, MoveObject, etc.) with validation
    *   Format: Dart source code with sealed class hierarchy
    *   Created in: Iteration 3, Task 1

*   **API Contract Documentation (Markdown)** - Internal API specifications
    *   Purpose: Document public APIs for EventRecorder, EventReplayer, ITool, Document
    *   Format: Markdown with Dart code examples
    *   Created in: Iteration 3, Task 6

*   **Tool State Machine Diagrams (PlantUML)** - Document tool behavior
    *   Purpose: Clarify state transitions for Pen Tool and Direct Selection Tool
    *   Format: PlantUML State Diagrams
    *   Created in: Iteration 6, Task 3

*   **Testing Strategy Document (Markdown)** - Test coverage and approach
    *   Purpose: Define unit, widget, and integration test expectations
    *   Format: Markdown
    *   Created in: Iteration 9, Task 4

---

<!-- anchor: directory-structure -->
## 3. Directory Structure

<!-- anchor: root-directory -->
*   **Root Directory:** `wiretuner/`

<!-- anchor: structure-definition -->
*   **Structure Definition:**

```
wiretuner/
├── lib/
│   ├── main.dart                          # Application entry point
│   ├── app.dart                           # Root widget, routing, theme
│   │
│   ├── presentation/                      # UI Layer
│   │   ├── pages/
│   │   │   └── main_page.dart             # Main editor page
│   │   ├── widgets/
│   │   │   ├── canvas/
│   │   │   │   ├── canvas_widget.dart     # Main canvas container
│   │   │   │   ├── canvas_painter.dart    # CustomPainter implementation
│   │   │   │   └── overlay_painter.dart   # Tool overlays (handles, guides)
│   │   │   ├── toolbar/
│   │   │   │   ├── tool_toolbar.dart      # Tool selection UI
│   │   │   │   └── tool_button.dart       # Individual tool button
│   │   │   └── panels/
│   │   │       ├── properties_panel.dart  # Object properties editor
│   │   │       └── layers_panel.dart      # Layer management (future)
│   │   └── providers/
│   │       ├── document_provider.dart     # Document state (ChangeNotifier)
│   │       └── tool_manager_provider.dart # Active tool state
│   │
│   ├── application/                       # Application Layer (Use Cases)
│   │   ├── tools/
│   │   │   ├── tool_interface.dart        # ITool abstract interface
│   │   │   ├── tool_manager.dart          # Tool lifecycle management
│   │   │   ├── pen_tool.dart              # Pen tool implementation
│   │   │   ├── selection_tool.dart        # Selection tool
│   │   │   ├── direct_selection_tool.dart # Direct selection tool
│   │   │   ├── rectangle_tool.dart        # Rectangle shape tool
│   │   │   ├── ellipse_tool.dart          # Ellipse shape tool
│   │   │   ├── polygon_tool.dart          # Polygon shape tool
│   │   │   └── star_tool.dart             # Star shape tool
│   │   └── services/
│   │       ├── document_service.dart      # Document CRUD operations
│   │       └── cursor_service.dart        # Cursor management
│   │
│   ├── domain/                            # Domain Layer (Business Logic)
│   │   ├── models/
│   │   │   ├── document.dart              # Document root model
│   │   │   ├── layer.dart                 # Layer model
│   │   │   ├── vector_object.dart         # Abstract base class
│   │   │   ├── path.dart                  # Path model
│   │   │   ├── shape.dart                 # Shape model (rect, ellipse, etc.)
│   │   │   ├── segment.dart               # Path segment model
│   │   │   ├── anchor_point.dart          # Anchor point model
│   │   │   ├── style.dart                 # Fill/stroke style model
│   │   │   ├── transform.dart             # Transformation matrix model
│   │   │   ├── selection.dart             # Selection state model
│   │   │   └── viewport.dart              # Viewport state (pan, zoom)
│   │   ├── events/
│   │   │   ├── event_base.dart            # Base event class
│   │   │   ├── path_events.dart           # CreatePath, AddAnchor, etc.
│   │   │   ├── object_events.dart         # MoveObject, DeleteObject, etc.
│   │   │   └── style_events.dart          # ModifyStyle events
│   │   └── services/
│   │       ├── geometry_service.dart      # Bezier math, intersections
│   │       ├── hit_test_service.dart      # Point-in-path, distance calculations
│   │       └── path_operations.dart       # Boolean ops (future), offset, simplify
│   │
│   ├── infrastructure/                    # Infrastructure Layer
│   │   ├── event_sourcing/
│   │   │   ├── event_recorder.dart        # Records events with sampling
│   │   │   ├── event_replayer.dart        # Replays events to reconstruct state
│   │   │   ├── event_dispatcher.dart      # Routes events to handlers
│   │   │   ├── event_handler_registry.dart # Maps event types to handlers
│   │   │   ├── event_sampler.dart         # 50ms throttling logic
│   │   │   ├── snapshot_manager.dart      # Snapshot creation/loading
│   │   │   └── snapshot_serializer.dart   # Document <-> binary codec
│   │   ├── persistence/
│   │   │   ├── database_provider.dart     # SQLite connection management
│   │   │   ├── event_store.dart           # Event table CRUD
│   │   │   ├── snapshot_store.dart        # Snapshot table CRUD
│   │   │   └── metadata_store.dart        # Metadata table CRUD
│   │   ├── import_export/
│   │   │   ├── svg_exporter.dart          # SVG 1.1 XML generation
│   │   │   ├── pdf_exporter.dart          # PDF 1.7 generation
│   │   │   ├── ai_importer.dart           # Adobe Illustrator parser
│   │   │   └── svg_importer.dart          # SVG XML parser
│   │   └── logging/
│   │       └── logger_config.dart         # Logging setup (file + console)
│   │
│   └── utils/                             # Shared utilities
│       ├── constants.dart                 # App-wide constants
│       └── extensions.dart                # Dart extension methods
│
├── test/                                  # Unit and widget tests
│   ├── domain/
│   │   ├── models/
│   │   │   ├── path_test.dart
│   │   │   ├── shape_test.dart
│   │   │   └── document_test.dart
│   │   └── services/
│   │       ├── geometry_service_test.dart
│   │       └── hit_test_service_test.dart
│   ├── infrastructure/
│   │   ├── event_sourcing/
│   │   │   ├── event_recorder_test.dart
│   │   │   ├── event_replayer_test.dart
│   │   │   └── snapshot_manager_test.dart
│   │   └── persistence/
│   │       ├── event_store_test.dart
│   │       └── snapshot_store_test.dart
│   └── application/
│       └── tools/
│           ├── pen_tool_test.dart
│           └── selection_tool_test.dart
│
├── integration_test/                      # End-to-end integration tests
│   ├── document_lifecycle_test.dart       # Save/load workflow
│   ├── pen_tool_workflow_test.dart        # Create path end-to-end
│   └── undo_redo_test.dart                # Undo/redo operations
│
├── docs/                                  # Documentation and design artifacts
│   ├── diagrams/                          # Architecture diagrams
│   │   ├── component_overview.puml        # Component diagram source
│   │   ├── event_sourcing_sequences.puml  # Sequence diagrams source
│   │   ├── database_erd.puml              # ERD diagram source
│   │   ├── domain_model_class.puml        # Class diagram source
│   │   └── tool_state_machines.puml       # State diagrams source
│   ├── api/                               # API documentation
│   │   └── internal_api_contracts.md      # Internal API specifications
│   ├── adr/                               # Architectural Decision Records (optional)
│   │   ├── 001-event-sourcing-choice.md
│   │   ├── 002-flutter-desktop-choice.md
│   │   └── 003-sqlite-file-format.md
│   └── testing/
│       └── testing_strategy.md            # Test coverage and approach
│
├── api/                                   # Event schema definitions (not HTTP APIs)
│   ├── event_schema.dart                  # Sealed event class hierarchy
│   └── event_types.md                     # Documentation of event types
│
├── assets/                                # Application assets
│   ├── icons/                             # Tool icons, app icons
│   └── fonts/                             # Custom fonts (if needed)
│
├── macos/                                 # macOS platform-specific code
│   └── Runner/                            # Flutter-generated
│
├── windows/                               # Windows platform-specific code
│   └── runner/                            # Flutter-generated
│
├── .github/
│   └── workflows/
│       └── build.yml                      # CI/CD pipeline (GitHub Actions)
│
├── analysis_options.yaml                  # Dart analyzer linting rules
├── pubspec.yaml                           # Flutter dependencies
├── README.md                              # Project README
├── CHANGELOG.md                           # Version history
└── LICENSE                                # License file (e.g., MIT)
```

**Justification:**
*   **Layered Structure:** Clear separation of concerns (presentation, application, domain, infrastructure)
*   **Feature-Based Organization:** Tools grouped together, event sourcing components co-located
*   **Testability:** Parallel `test/` structure mirrors `lib/` for easy navigation
*   **Documentation:** Centralized `docs/` with dedicated subdirectories for diagrams, API contracts, and ADRs
*   **Artifacts:** `api/` contains event schema definitions (treated as contracts despite being internal)
*   **Platform-Specific:** macOS/Windows directories auto-generated by Flutter, minimal custom code expected

---

<!-- anchor: iteration-plan-overview -->
## 4. Iteration Plan

<!-- anchor: total-iterations -->
*   **Total Iterations Planned:** 9 iterations (mapping to the 9 phases defined in ticket index)

<!-- anchor: iteration-dependencies -->
*   **Iteration Dependencies:**
    *   **I1 (Foundation & Setup):** No dependencies, starting point
    *   **I2 (Core Event System):** Depends on I1 (database and project setup)
    *   **I3 (Vector Data Model):** Depends on I1 (project setup), can partially overlap with I2
    *   **I4 (Rendering Engine):** Depends on I3 (data models), I2 (event system for state changes)
    *   **I5 (Tool System Architecture):** Depends on I4 (canvas and rendering)
    *   **I6 (Pen Tool):** Depends on I5 (tool framework)
    *   **I7 (Shape Tools):** Depends on I5 (tool framework), can partially overlap with I6
    *   **I8 (Direct Manipulation):** Depends on I5 (tool framework), I6 (pen tool for anchor creation)
    *   **I9 (File Operations & Import/Export):** Depends on I2 (event system), I3 (data models)

---

**Note:** Detailed iteration plans with granular tasks are provided in separate files: `02_Iteration_I1.md` through `02_Iteration_I9.md`
