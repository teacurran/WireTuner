# Project Plan: WireTuner Milestone 0.1

**Version:** 1.0
**Date:** 2025-11-08
**Generated By:** Codex GPT-5

<!-- anchor: project-overview -->
## 1. Project Overview

* **Goal:** Deliver WireTuner v0.1 as a Flutter desktop vector editor that captures every creative action through a hybrid event-sourced architecture, supports multi-window documents, and ships Tier-2 Adobe Illustrator import plus reliable save/load flows.
* **High-Level Requirements Summary:**
  - Build a performant CustomPainter-based canvas with pan/zoom, selection overlays, and strict macOS/Windows feature parity.
  - Implement hybrid persistence: immutable document snapshots for instant load plus sampled history logs for replay, undo/redo, and future collaboration.
  - Provide core tooling (pen, selection, direct selection, rectangle, ellipse, polygon, star) with anchor/BCP manipulation, undo grouping, and 50 ms sampling.
  - Ship persistence + interoperability features: semantic file-version handling, SQLite-backed `.wiretuner` format, SVG/PDF export, and Tier-2 AI import with compatibility warnings.
  - Establish CI, testing, and diagnostics (logging, metrics) that run across both desktop platforms.
* **Key Assumptions:**
  - Single primary developer with Flutter/Dart expertise executes the plan; autonomous agents collaborate per iteration tasks.
  - Flutter 3.16+ with Dart 3.2+ and `sqflite_common_ffi` provide acceptable desktop stability and SQLite throughput.
  - Local-first workflow; no network sync in v0.1, but event IDs (UUID + timestamps) keep collaboration-ready underpinnings.
  - Target hardware is modern desktop/laptop (8 GB RAM, SSD) ensuring 60 FPS canvas and <100 ms document load from snapshots.
  - Existing architecture decisions (Decisions 1–7 in WireTuner blueprint) remain authoritative; deviations trigger ADR updates.
* **Project Scale Classification:** Large — per Table 8.1, scope involves 5 iterations, 35+ granular tasks, 8+ architecture artifacts, cross-platform deliverables, and tens of KLOC. Team-equivalent size (autonomous agents) exceeds 10 parallel roles, timeline spans multiple months, and complexity includes rendering, persistence, import/export, and tooling subsystems.

<!-- anchor: core-architecture -->
## 2. Core Architecture

* **Architectural Style:** Hybrid event-sourced layered desktop application. Presentation (Flutter widgets + CustomPainter) drives tool controllers (application layer), which emit immutable domain events applied to the domain layer (document, geometry, styling) and persisted through the infrastructure layer (SQLite event store + snapshot manager). Multi-document support uses MDI windowing with isolated state per document.
* **Technology Stack:**
  * **Frontend:** Flutter desktop (macOS/Windows runners), Material/Cupertino widgets, CustomPainter, Provider for state propagation, vector_math for transforms.
  * **Backend/Application Services:** Dart service classes for tool orchestration, event recorder/replayer, snapshot scheduler, undo/redo navigator, viewport controller.
  * **Database:** SQLite via `sqflite_common_ffi`, normalized schema for `events`, `snapshots`, `metadata`, plus pragma WAL for durability.
  * **Messaging/Queues:** In-process event bus (stream controller) for distributing domain events to handlers; no external brokers.
  * **Deployment:** GitHub Actions CI (macOS + Windows runners) producing notarized `.app/.dmg` and signed `.exe/MSIX`; releases published via GitHub Releases before future store submissions.
  * **Other Key Libraries/Tools:** `freezed` + `json_serializable` for immutable models, `logger` for structured logs, `xml`/`pdf` packages for import/export, `melos` for workspace orchestration, `clang-format`/`dart format` for linting.
* **Key Components/Services:**
  - **UI Shell & Window Manager:** Hosts application chrome, menu, window lifecycle; coordinates doc routing per Decision 2. (Component diagram refined in I1.T2.)
  - **Tool Framework:** Interface + state machines for selection, pen, shape, direct manipulation tools; injects tool overlays into canvas. (Sequence + state diagrams in I3 tasks.)
  - **Event Recorder & Sampler:** Aggregates pointer/key events, enforces 50 ms sampling, writes to SQLite; integrates with undo grouping. (Specs in I1.T3.)
  - **Event Replayer & Snapshot Manager:** Loads latest snapshot then replays remaining events for fast open and timeline scrubbing; exposes API to undo navigator (I4.T1/T2).
  - **Vector Engine:** Immutable data models (paths, shapes, anchors, styles), geometry utilities (hit testing, boolean ops) powering rendering (I2 tasks).
  - **Rendering Pipeline:** CustomPainter, viewport transformer, selection overlay renderer, offscreen caching (I2.T4–T6).
  - **Persistence Services:** File-versioning service, save/load orchestrator, AI/SVG import/export modules (I5 tasks).
* **Data Model Overview:** Documents contain ordered layers with vector objects (paths, shapes) composed of segments and anchors. Styles encapsulate fill/stroke/opacity; transforms stored as matrices. Persistent schema stores events (JSON payloads) and snapshots (binary-serialized documents). ERD + schema definitions captured in I2.T1/I2.T2 (Mermaid + Markdown) and referenced by persistence tasks.
* **API Contract Style:** Internal contracts documented via Markdown + JSON Schema. Event payloads follow versioned JSON schema; persistence API (save/load/export/import) documented in `api/file_format_spec.md`. No external HTTP APIs; future collaboration will wrap existing event schema in WebSocket/gRPC contracts (not in scope now).
* **Communication Patterns:** Event-driven command stream (tools → recorder → dispatcher), synchronous queries (UI → document provider), and pub/sub (Provider notifies widgets). Sequence diagrams for pen creation, replay, undo, and import flows produced in Iterations 1, 3, and 5 (see Section 2.1 references).

<!-- anchor: key-architectural-artifacts -->
## 2.1. Key Architectural Artifacts Planned

* **Component Diagram (PlantUML) — `docs/diagrams/component_overview.puml` (I1.T2):** Visualizes UI shell, tool system, event core, vector engine, and persistence interfaces to align autonomous agents.
* **Event Flow Sequence Diagram (Mermaid) — `docs/diagrams/event_flow_sequence.mmd` (I1.T5):** Shows sampling → persistence → replay pipeline for onboarding backend/service agents.
* **Event Schema Reference (Markdown + JSON snippets) — `docs/reference/event_schema.md` (I1.T6):** Defines required fields, UUID/timestamp formats, sampling metadata for recorder/replayer implementations.
* **Data & Snapshot ERD (Mermaid) — `docs/diagrams/data_snapshot_erd.mmd` (I2.T1):** Captures SQLite tables, relationships, and snapshot cadence to guide persistence optimizations.
* **Vector Model Specification (Markdown) — `docs/reference/vector_model.md` (I2.T2):** Describes document/layer/path/shape immutability contracts for rendering + tool agents.
* **Tool State Machine Diagram (PlantUML) — `docs/diagrams/tool_framework_state_machine.puml` (I3.T2):** Details activation, pointer events, overlays, and undo grouping for pen/selection tools.
* **Undo/Redo Timeline Diagram (Mermaid) — `docs/diagrams/undo_timeline.mmd` (I4.T2):** Maps operation-based grouping, event navigation, and snapshot alignment for QA + backend agents.
* **File Format & Migration Spec (Markdown + JSON Schema) — `api/file_format_spec.md` (I5.T2):** Documents semantic version handling, degradation paths, and compatibility matrix per Decision 4.
* **AI Import Feature Matrix (Markdown) — `docs/reference/ai_import_matrix.md` (I5.T4):** Lists Tier-2 supported constructs, fallbacks, and warning messages for import agents.
* **Platform Parity QA Checklist (Markdown) — `docs/qa/platform_parity_checklist.md` (I5.T6):** Guides dual-platform verification aligning with Decision 6.

<!-- anchor: directory-structure -->
## 3. Directory Structure

* **Root Directory:** `wiretuner-app/`
* **Structure Definition:**
  ~~~
  wiretuner-app/
  ├── api/
  │   └── file_format_spec.md             # Semantic version + compatibility contract
  ├── docs/
  │   ├── diagrams/                       # PlantUML/Mermaid sources (component, sequence, ERD, timelines)
  │   ├── reference/                      # Architecture decisions, event schema, vector model, import matrix
  │   ├── qa/                             # Platform parity checklist, manual QA runbooks
  │   └── adr/                            # Architectural decision records (future deviations)
  ├── packages/
  │   ├── app_shell/                      # Flutter UI shell + window management
  │   ├── event_core/                     # Recorder, sampler, replayer, snapshot services
  │   ├── vector_engine/                  # Data models, geometry math, hit testing
  │   ├── tool_framework/                 # Tool interfaces, pen/selection/shape implementations
  │   └── io_services/                    # Save/load, versioning, import/export pipelines
  ├── scripts/
  │   ├── ci/                             # GitHub Actions workflows, lint/test scripts
  │   └── tooling/                        # Dev automation (e.g., diagram render, codegen helpers)
  ├── test/
  │   ├── unit/                           # Model/service tests (Dart `test`)
  │   ├── widget/                         # Flutter widget tests for canvas/tools
  │   └── integration/                    # Save/load/import/export end-to-end tests
  ├── tools/
  │   └── melos_workspace.yaml            # Multi-package orchestration config
  ├── analysis_options.yaml               # Lint configuration enforcing immutability & safety
  ├── pubspec.yaml                        # Workspace dependencies, scripts
  ├── README.md                           # Developer quickstart + status badges
  └── .codemachine/                       # Agent-generated artifacts (plan, manifests)
  ~~~
  *Hierarchy groups code by responsibility, isolates reusable packages for autonomous agent ownership, and reserves `docs/diagrams` + `api/` for mandatory artifacts so that iteration tasks reference predictable paths.*

<!-- anchor: directives-process -->
## 4. Directives & Strict Process

1. **Command Hygiene:** Autonomous agents must avoid exploratory listings (`ls`, `dir`) unless explicitly required; rely on targeted file access and repository knowledge to conserve context per protocol.
2. **Blueprint Discipline:** Before editing, agents craft mental blueprints, stage entire content in-memory, then write via single atomic redirections (`>`). No incremental edits that violate sampling/undo requirements.
3. **Anchored Artifacts:** Every heading/task inclusion must be preceded by a unique HTML anchor (`<!-- anchor: ... -->`) to stay manifest-addressable.
4. **Artifact Formats:** PlantUML for component/state diagrams, Mermaid for sequence/ERD/timeline visuals, Markdown/JSON for specs, and OpenAPI-style schema conventions for file format docs to ensure diff-friendly outputs.
5. **Quality Gates:** Each task enforces acceptance criteria including lint/test execution, schema validation, CI script updates, or diagram rendering checks; agents document validation evidence in task notes.
6. **Concurrency Rules:** Respect dependency graph; only tasks flagged as parallelizable may run simultaneously, protecting shared resources (databases, schema files, CI configs).
7. **Traceability:** Update `docs/adr/` when deviating from Decisions 1–7, and keep manifest entries synced so downstream agents can fetch exact sections without scanning entire files.
