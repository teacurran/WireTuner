<!-- anchor: project-plan-wiretuner -->
# Project Plan: WireTuner Milestone 0.1

**Version:** 1.0  
**Date:** 2025-11-06  
**Generated By:** Codex GPT-5

<!-- anchor: section-1-project-overview -->
## 1. Project Overview

*   **Goal:** Deliver WireTuner Milestone 0.1 as a desktop-grade vector editor with functioning pen and shape tools, event-sourced history, anchor/BCP manipulation, and reliable save/load workflows.
*   **High-Level Requirements Summary:**
    - Flutter desktop app (macOS/Windows) initialized with SQLite-backed event store and immutable data models.
    - Complete event sourcing loop: modeling, recording with 50 ms sampling, persistence, snapshotting, replay, and undo/redo navigation.
    - Geometry/data layer for paths, shapes, and documents feeding a CustomPainter-based rendering stack with viewport transforms and selection visuals.
    - Tooling framework with selection/direct selection plus pen and shape tools (rect/ellipse/polygon/star) and direct manipulation of anchors, BCPs, and objects.
    - Persistence and interoperability: native .wiretuner save/load with versioning, plus SVG/PDF export and AI/SVG import foundation.
*   **Key Assumptions:**
    - Flutter 3.16+/Dart 3.2+ with `sqflite_common_ffi`, `provider`, `vector_math`, `pdf`, and `xml` form the baseline stack; no mobile/web scope in 0.1.
    - Event store serialization uses JSON payloads within SQLite; snapshot cadence fixed at 1,000 events with gzip compression unless profiling dictates otherwise.
    - Single developer execution but agents can parallelize within dependency graph; all tasks must respect Milestone 0.1 critical path (T001–T035) before tackling import/export stretch (T036–T039).
    - Product vision and architecture notes referenced in `/thoughts/shared/...` stay authoritative; this plan aligns with those artifacts and extends them into executable workstreams.
*   **Project Scale Classification (per Section 8.1 table):** Large — multi-phase desktop application with 9 functional phases, ~40 tickets, numerous architectural artifacts, and 5+ major subsystems.

<!-- anchor: section-2-core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Event-Sourced Layered Desktop Monolith (Presentation ↔ Application ↔ Domain ↔ Infrastructure) with immutable data models and snapshot-assisted replay.
*   **Technology Stack:**
    *   Frontend: Flutter desktop (macOS/Windows), Material 3 widgets, Provider/ChangeNotifier for reactive UI, CustomPainter for canvas.
    *   Backend/Application: Dart services for event recorder/replayer, tool controllers, command processors, geometry utilities.
    *   Database: SQLite via `sqflite_common_ffi`, native `.wiretuner` container with `metadata`, `events`, and `snapshots` tables.
    *   Messaging/Queues: In-process event bus/dispatcher layered over Provider notifications; no external queues in Milestone 0.1.
    *   Deployment: GitHub Actions CI building notarized macOS `.app/.dmg` and signed Windows `.exe` installers; manual distribution for 0.1.
    *   Other Key Libraries/Tools: `freezed` (immutable models), `json_serializable`, `vector_math`, `logger`, `integration_test`, PlantUML/Mermaid for diagrams, OpenAPI/JSON Schema for specs.
*   **Key Components/Services:**
    - UI Shell & Panels: Window chrome, layer/object inspector, toolbars, status bars (Component Diagram v1 in I1.T2).
    - Canvas & Rendering Pipeline: CustomPainter viewport, selection overlay, dirty-region tracker (Rendering Component Diagram in I2.T2).
    - Tool Framework: `ToolManager`, selection/direct selection, pen, shape tools, cursor/overlay services (Tool Interaction Sequence in I3.T2).
    - Event Core: Recorder with sampler, dispatcher, replayer, snapshot manager, undo/redo navigator (Event Flow Sequence in I1.T3).
    - Vector Engine & Geometry: Immutable Document/Path/Shape models, Bezier math, hit-testing, transform stack (Domain ERD evolution in I2.T1).
    - Persistence & File Ops: SQLite repo, versioned save/load, import/export services (File Ops Activity Diagram in I5.T2).
*   **Data Model Overview:**
    - Persistent schema features `metadata(document_id, format_version)`, append-only `events(event_sequence, event_type, payload JSON)`, and `snapshots(blob)` with indexes enabling deterministic replay.
    - In-memory domain objects (Document, Layer, VectorObject, Path, Shape, Segment, Anchor, Style, Selection, Viewport) remain immutable via Freezed; transforms captured as Matrix4, styles hold fill/stroke, selections track object + anchor IDs.
    - Iteration I2.T1 produces a Mermaid ERD bridging persistent schema to domain aggregates, while I2.T3 drafts a JSON Schema for event payload validation.
*   **API Contract Style:** Internal event schema defined via JSON Schema + Markdown tables; file operations documented through OpenAPI-lite YAML describing CLI/service invocations for save/load/export commands (spec baseline produced in I4.T3).
*   **Communication Patterns:**
    - Event-driven user interaction → tool controller → recorder → dispatcher → document provider; Sequence diagram created in I1.T3.
    - Request/response queries from tools/rendering to document snapshot and geometry services; class diagram refined in I2.T2.
    - Provider-based pub/sub for UI rebuilds; instrumentation design captured in I3.T4.

<!-- anchor: section-2-1-key-artifacts -->
## 2.1. Key Architectural Artifacts Planned

*   Component Diagram (PlantUML) – Depict UI shell, canvas, tool system, event core, persistence (Created in `I1.T2`, `docs/diagrams/component_overview.puml`).
*   Event Flow Sequence (PlantUML) – Show pointer input through recorder/snapshots/undo (Created in `I1.T3`, `docs/diagrams/event_flow_sequence.puml`).
*   Data & Domain ERD (Mermaid) – Capture SQLite tables and domain aggregates (Created in `I2.T1`, `docs/diagrams/data_domain_erd.mmd`).
*   Rendering Pipeline Diagram (PlantUML) – Map viewport, painter, selection overlay interactions (Created in `I2.T2`, `docs/diagrams/rendering_pipeline.puml`).
*   Tool Interaction Sequence (PlantUML) – Pen/selection lifecycle including sampling (Created in `I3.T2`, `docs/diagrams/tool_interaction_sequence.puml`).
*   Event Payload JSON Schema (JSON) – Validate event types and payload fields (Created in `I2.T3`, `docs/specs/event_payload.schema.json`).
*   Save/Load API Contract (OpenAPI v3 YAML) – Document CLI/UI-triggered persistence endpoints (Created in `I4.T3`, `api/save_load.yaml`).
*   File Ops Activity Diagram (Mermaid) – Visualize export/import workflows (Created in `I5.T2`, `docs/diagrams/file_ops_activity.mmd`).

<!-- anchor: section-3-directory-structure -->
## 3. Directory Structure

*   **Root Directory:** `wiretuner/`
*   **Structure Definition:**
    ~~~
    wiretuner/
    ├── lib/
    │   ├── main.dart
    │   ├── src/
    │   │   ├── app/
    │   │   │   ├── shell/           # Window scaffolding, menus, panels
    │   │   │   ├── routing/
    │   │   │   └── theme/
    │   │   ├── canvas/
    │   │   │   ├── painter/         # CustomPainter implementations
    │   │   │   ├── viewport/        # Pan/zoom, transforms
    │   │   │   └── overlays/        # Selection, guides
    │   │   ├── tools/
    │   │   │   ├── framework/
    │   │   │   ├── selection/
    │   │   │   ├── direct_selection/
    │   │   │   ├── pen/
    │   │   │   └── shapes/          # rect/ellipse/polygon/star
    │   │   ├── domain/
    │   │   │   ├── models/
    │   │   │   ├── geometry/
    │   │   │   └── selection/
    │   │   ├── event_sourcing/
    │   │   │   ├── recorder/
    │   │   │   ├── replayer/
    │   │   │   ├── snapshots/
    │   │   │   └── persistence/
    │   │   └── services/
    │   │       ├── file_ops/
    │   │       ├── telemetry/
    │   │       └── diagnostics/
    ├── test/
    │   ├── unit/
    │   ├── widget/
    │   └── integration/
    ├── integration_test/
    ├── tools/
    │   └── scripts/                  # Build, lint, coverage helpers
    ├── api/
    │   ├── save_load.yaml
    │   └── export_import.yaml
    ├── docs/
    │   ├── diagrams/
    │   │   ├── component_overview.puml
    │   │   ├── event_flow_sequence.puml
    │   │   ├── data_domain_erd.mmd
    │   │   ├── rendering_pipeline.puml
    │   │   ├── tool_interaction_sequence.puml
    │   │   └── file_ops_activity.mmd
    │   ├── specs/
    │   │   ├── event_payload.schema.json
    │   │   └── persistence_contract.md
    │   └── adr/
    ├── assets/
    │   └── icons/
    ├── scripts/
    │   └── ci/
    ├── analysis_options.yaml
    ├── pubspec.yaml
    ├── README.md
    └── .github/
        └── workflows/
    ~~~
    Key justification: diagrams/specs isolated under `docs/` for agent-friendly management; `api/` hosts OpenAPI specs; `tools/scripts` separate automation from Flutter `scripts/ci` to keep execution contexts clean.

<!-- anchor: section-4-directives -->
## 4. Directives & Strict Process

*   **Command & Output Discipline:** Agents avoid exploratory `ls`/`dir` commands per protocol; rely on manifest and targeted globbing via scripted helpers; deviations require explicit justification in commits.
*   **Single-Source Artifacts:** Architectural diagrams/specs managed as text (PlantUML/Mermaid/OpenAPI/JSON) with lint/validation tasks baked into iteration acceptance criteria; binary exports prohibited.
*   **Immutable Data Enforcement:** All domain edits must flow through event handlers and produce immutable copies; direct mutation in tools or rendering layers is disallowed and should trigger CI lint failures (`analysis_options.yaml` enforces immutability hints).
*   **Review & Testing Hooks:** Every task must specify unit/widget/integration expectations up front; PR templates link tasks to ticket IDs (T001–T039) and require checklist confirmation for sampling, snapshotting, and persistence concerns.
*   **Observability Baseline:** Logging/telemetry scaffolding planned during I1 to ensure subsequent iterations can instrument performance (FPS, replay latency) without rework; agents must wire new subsystems into the shared logger.

<!-- anchor: section-5-iteration-overview -->
## 5. Iteration Plan Overview

*   **Total Iterations Planned:** 5 (I1 Foundation/Event Core, I2 Data & Rendering, I3 Tool System & Pen, I4 Shapes & Direct Manipulation, I5 Persistence & Import/Export).
*   **Iteration Dependencies:**
    - `I1` seeds project setup, database integration, and event architecture artifacts; all other iterations depend on its deliverables.
    - `I2` consumes event core to build models and rendering, unlocking `I3` tooling work; `I3` must finish base tools before `I4` extends shapes/manipulation.
    - `I4` outputs interaction behaviors and save/load API contracts needed by `I5` for persistence, file versioning, and import/export services.
    - Import/export (I5) depends on serialization schemas, rendering fidelity, and manipulation correctness from earlier iterations to ensure parity between UI state and stored documents.
*   Detailed task breakdowns live in `02_Iteration_I*.md` files with anchors for autonomous agent retrieval.
