# Project Plan: WireTuner

**Version:** 1.0
**Date:** 2025-11-10
**Generated By:** Codex (GPT-5)

<!-- anchor: project-overview -->
## 1. Project Overview
* **Goal:** Deliver a cross-platform Flutter desktop vector studio with multi-artboard workflows, event-sourced history, and high-fidelity import/export plus collaboration readiness.
* **High-Level Requirements Summary:**
  - Comprehensive drawing toolset (pen, selection, shapes, boolean ops, typography) with screen-space snapping, intelligent nudging, and per-tool HUDs.
  - Event sourcing to SQLite (.wiretuner) with configurable sampling, auto-save, snapshots, deterministic replay, and timeline UI.
  - Multi-artboard navigator, per-artboard viewport/selection/layers, navigator thumbnails, presets, window lifecycle, and cross-document tabs.
  - Import/export stack for SVG (tier 1/2), PDF (via SVG-to-PDF), AI (PDF-compatible), JSON archival, per-artboard export, and robust error handling.
  - Platform integration (QuickLook/Explorer thumbnails, native dialogs, file associations) plus telemetry, feature flags, and OT-ready collaboration gateway.
  - Performance, reliability, and accessibility mandates: <100 ms load for 10K events, ≥5K events/sec replay, ≥60 FPS canvas, undo depth controls, WCAG-compliant UI.
* **Key Assumptions:**
  - Flutter 3.x desktop, Dart 3.x, Clean Architecture layers, Freezed models, Provider for DI, sqflite for persistence, resvg for PDF, LaunchDarkly for flags.
  - Users have macOS 10.15+/Windows 10+ hardware with ≥4 GB RAM; touch/stylus support is deferred.
  - AWS (EKS, RDS, ElastiCache, S3, CloudFront) is the reference cloud; on-prem mirrors follow the same contracts.
  - Collaboration requires OT sequencing with WebSocket + GraphQL APIs; offline mode remains first-class.
  - Scope classified as **Large** per spec: 5 iterations, 5-9 tasks each, multiple architectural artifacts, complex directory layout.

<!-- anchor: core-architecture -->
## 2. Core Architecture
* **Architectural Style:** Clean layered desktop monolith (Presentation → Application → Domain → Infrastructure) with service-oriented backend (GraphQL + WebSocket microservices) and hybrid event-sourced persistence.
* **Technology Stack:**
  * Frontend: Flutter 3.x desktop, CustomPainter, Provider/ChangeNotifier, Freezed/json_serializable, melos workspace.
  * Backend: Dart Frog (preferred) or Node.js (TypeScript) for Sync API + Collaboration Gateway, Redis pub/sub, resvg workers, Prometheus/OpenTelemetry instrumentation.
  * Database: SQLite 3.x WAL (.wiretuner) for document events/snapshots, PostgreSQL 14+ for collaboration metadata/settings, Redis Cluster for pub/sub + queues.
  * Messaging/Queues: Redis Streams for export/import jobs, LaunchDarkly streaming for feature flags, SQS-compatible fallback for background conversions.
  * Deployment: AWS EKS + Terraform, Docker images, CloudFront/S3 for installers/artifacts, GitHub Actions CI/CD.
  * Other Libraries/Tools: resvg (SVG→PDF), xml (SVG parsing), json-schema for config validation, OpenAPI/GraphQL SDL, FFI wrappers, OpenTelemetry SDK.
* **Key Components/Services:**
  - DesktopShell & NavigatorService orchestrating windows, tabs, thumbnails, artboard lifecycle (Component Diagram in `docs/diagrams/component_overview.puml`, Iteration I1.T2).
  - InteractionEngine + ToolingFramework handling gestures, snapping, undo stacks, OT integration.
  - EventStoreServiceAdapter (SQLite), SnapshotManager (background isolates), ReplayService (checkpoint cache).
  - RenderingPipeline (GPU/CPU fallback) with overlays for anchors, sampling heatmaps, performance metrics.
  - ImportExportService with pluggable adapters (SVG, PDF, AI, JSON) and queue-backed conversions.
  - CollaborationGateway + SyncAPI (GraphQL/WebSocket) with OT resolver, presence, telemetry hooks.
  - SettingsService + FeatureFlagClient, TelemetryClient, BackgroundWorkerPool, SecurityGateway wrappers.
  - Navigator thumbnails, QuickLook/Explorer extensions, Command Palette & HUD overlays.
* **Data Model Overview:**
  - Immutable Freezed entities: Document, DocumentMetadata, Artboard, Layer, VectorObject (path/shape/text/compound), VectorPath, AnchorPoint, SelectionState, ViewportState, Event, Snapshot, ExportJob, CollaborationSession.
  - Each event carries UUID, sequence, timestamp, userId, artboardId, eventType, eventData JSON; snapshots compress serialized document state.
  - ERD covering relations (Document→Artboard→Layer→VectorObject→VectorPath→AnchorPoint, plus Event/Snapshot/ExportJob) captured in `docs/diagrams/domain_erd.puml` (Iteration I1.T3).
* **API Contract Style:** Hybrid GraphQL (metadata/settings), WebSocket (event streaming/presence), REST (telemetry ingest/export downloads). Initial GraphQL SDL + OpenAPI snippets authored Iteration I2.T2 in `api/schema.graphql` and `api/telemetry.yaml`.
* **Communication Patterns:**
  - Clean Architecture boundaries enforced via Providers; InteractionEngine emits commands consumed by EventStore/Snapshot/Replay adapters.
  - Desktop ↔ backend via TLS GraphQL + WebSocket OT; Redis fan-out between collaboration pods; SQS/Redis Streams for background jobs.
  - Sequence diagrams (PlantUML) planned for pen tool, direct selection, save/snapshot, import/export, collaboration handshake (Iterations I2.T4 & I3.T5) in `docs/diagrams/sequence/*.puml`.

<!-- anchor: key-artifacts -->
## 2.1 Key Architectural Artifacts Planned
* Component Diagram (PlantUML) – Visualize Clean Architecture layers + services (`docs/diagrams/component_overview.puml`, created I1.T2) for onboarding/traceability.
* Data Model ERD (PlantUML/Mermaid) – Document → Artboard → Layer → VectorObject relationships (`docs/diagrams/domain_erd.puml`, I1.T3) to guide persistence & migration scripts.
* System Context & Deployment Diagrams (PlantUML) – Show desktop app, collaboration gateway, Sync API, Redis, PostgreSQL, S3 interactions (`docs/diagrams/system_context.puml`, `docs/diagrams/deployment.puml`, I1.T2/I2.T4).
* Sequenced Interaction Diagrams – Pen tool, save/snapshot, import/export, collaboration flows (`docs/diagrams/sequence/pen_flow.puml` etc., I2.T4, I3.T5) for OT + undo validation.
* API Specs – GraphQL SDL + OpenAPI YAML for telemetry/export endpoints (`api/schema.graphql`, `api/telemetry.yaml`, I2.T2) enabling autonomous agent scaffolding.
* Event & Snapshot Schema Docs – Markdown tables + JSON Schema (`docs/reference/event_catalog.md`, `docs/reference/snapshot_schema.json`, I2.T3) for persistence + tooling alignment.
* UI/UX Wireframe Atlas – Navigator, artboard window, history replay, collaboration panels in `docs/ui/wireframes/*.md` (I3.T4) to keep flow specs synchronized with build.
* Verification Matrix – Mapping FR/NFR to tests & KPIs in `docs/qa/verification_matrix.md` (I5.T4) for release readiness.

<!-- anchor: directory-structure -->
## 3. Directory Structure
* **Root Directory:** `wiretuner/`
* **Structure Definition:**
```
wiretuner/
├── api/
│   ├── schema.graphql              # GraphQL SDL (iterations I2+)
│   ├── telemetry.yaml              # OpenAPI for telemetry ingest
│   └── webhooks/                   # Future webhook specs
├── docs/
│   ├── diagrams/
│   │   ├── component_overview.puml
│   │   ├── domain_erd.puml
│   │   ├── system_context.puml
│   │   ├── deployment.puml
│   │   └── sequence/
│   │       └── *.puml
│   ├── reference/
│   │   ├── event_catalog.md
│   │   └── snapshot_schema.json
│   ├── ui/
│   │   ├── wireframes/
│   │   └── tokens.md
│   ├── qa/
│   │   └── verification_matrix.md
│   └── adr/
│       └── ADR-XXXX-*.md
├── packages/
│   ├── app/                        # Flutter desktop client
│   ├── core/                       # Domain + interaction engine
│   ├── infrastructure/             # Persistence, API adapters
│   └── tooling/                    # Worker/CLI utilities
├── server/
│   ├── collaboration-gateway/      # Dart Frog WebSocket service
│   ├── sync-api/
│   └── worker-export/
├── scripts/
│   ├── devtools/                   # linters, analyzers
│   └── ops/                        # terraform helpers, release scripts
├── terraform/
│   ├── envs/{dev,staging,prod}/
│   └── modules/
├── test/
│   ├── integration/
│   ├── golden/
│   └── smoke/
├── tools/
│   └── design-token-exporter/
├── melos.yaml
├── README.md
├── CONTRIBUTING.md
└── LICENSE
```
*Key choices:* monorepo keeps client, backend, infrastructure, and docs cohesive; `packages/` splits Clean Architecture layers for reuse, `docs/diagrams` hosts PlantUML/Mermaid artifacts for agents, and `terraform/` isolates IaC for Ops approvals.

<!-- anchor: directives-process -->
## 4. Directives & Strict Process
1. **Command Discipline:** Agents must avoid exploratory shell commands (no `ls` etc.) unless protocol explicitly allows; rely on structured knowledge and targeted scripts.
2. **Single-Write Rule:** Generate full content in-memory then emit via one atomic write per file (`>` redirection), followed immediately by Python line-count verification.
3. **Anchor Consistency:** Every major heading and task includes `<!-- anchor: ... -->` comments so downstream automation can deep link plan fragments.
4. **Traceability:** Reference requirement IDs (FR/NFR/ADR) in tasks, deliverables, and artifacts to keep audits straightforward.
5. **Parallelism Awareness:** Explicitly flag which tasks may run concurrently; dependencies must be enumerated to prevent race conditions across autonomous agents.
6. **Quality Gates:** Each iteration requires verification notes (tests, linting, validation scripts). No code merges without associated artifact updates (diagrams, specs, docs) per Clean Architecture governance.
7. **Change Control:** Deviations from stack/architecture require ADR drafts in `docs/adr/` and approval from the relevant architect persona before implementation begins.
