# System Architecture Blueprint: WireTuner

**Version:** 1.0
**Date:** 2025-11-05
**Generated By:** Claude Sonnet 4.5

---

<!-- anchor: introduction-goals -->
## 1. Introduction & Goals

<!-- anchor: project-vision -->
### 1.1. Project Vision

WireTuner is a professional vector drawing application built with Flutter for desktop platforms (macOS and Windows). It employs event-sourced architecture to enable advanced features like infinite undo/redo, collaborative editing, and comprehensive workflow replay. The application focuses on providing a robust, performant vector editing experience comparable to industry-standard tools like Adobe Illustrator, with the unique advantage of complete interaction history tracking.

<!-- anchor: key-objectives -->
### 1.2. Key Objectives

- **Event-Sourced Architecture**: Implement complete event sourcing with 50ms sampling rate to capture all user interactions
- **Professional Vector Editing**: Deliver pen tool, shape creation (rectangle, ellipse, polygon, star), and anchor/BCP manipulation capabilities
- **Native Performance**: Leverage Flutter's CustomPainter for high-performance canvas rendering on desktop platforms
- **Persistent History**: Store all events in SQLite with periodic snapshots for efficient state reconstruction
- **File Format Flexibility**: Support native .wiretuner format (SQLite-based) with import/export to SVG, PDF, and Adobe Illustrator files
- **Immutable Data Patterns**: Ensure data integrity and predictable state management through immutable data models
- **Milestone 0.1 Delivery**: Achieve working vector editor with pen tool, shape tools, direct manipulation, and save/load in ~21 days

<!-- anchor: scope -->
### 1.3. Scope

**In Scope:**
- Desktop application for macOS and Windows (initial focus)
- Core vector editing tools (pen, selection, direct selection, shapes)
- Event-sourced interaction recording and replay
- Canvas rendering with pan/zoom/viewport transforms
- Path and shape data models with Bezier curve support
- SQLite-based persistence with .wiretuner file format
- SVG and PDF export functionality
- Adobe Illustrator (.ai) file import
- Snapshot system for performance optimization

**Out of Scope (for Milestone 0.1):**
- Mobile platforms (iOS, Android)
- Web deployment
- Real-time collaborative editing (architecture supports it, not implemented in 0.1)
- Advanced effects (gradients, filters, patterns)
- Layer management and organization
- Text editing capabilities
- Plugin/extension system
- Cloud storage integration

<!-- anchor: key-assumptions -->
### 1.4. Key Assumptions

- **Single User Focus**: Milestone 0.1 targets single-user workflows; collaborative features are architectural future considerations
- **Desktop-First**: Optimized for desktop environments with keyboard shortcuts and mouse/trackpad input
- **SQLite Reliability**: SQLite provides sufficient performance and reliability for local file storage and event log persistence
- **Flutter Maturity**: Flutter desktop support is stable enough for production use on macOS and Windows
- **Event Volume**: 50ms sampling rate provides adequate granularity without overwhelming storage or replay performance
- **Snapshot Frequency**: Snapshots every 1000 events balance memory usage with replay speed
- **File Size**: Expected .wiretuner files remain manageable (< 100MB for typical projects) with snapshot compression
- **Development Environment**: Single developer with Flutter/Dart expertise, ~8 hours/day focused development
- **Reference Implementation**: Dissipate prototype provides architectural patterns but no direct code reuse

---

<!-- anchor: architectural-drivers -->
## 2. Architectural Drivers

<!-- anchor: functional-requirements -->
### 2.1. Functional Requirements Summary

**Core Vector Editing:**
- Pen tool with straight segments and Bezier curves
- Shape creation tools (rectangle, ellipse, polygon, star)
- Selection tool for object-level manipulation
- Direct selection tool for anchor point and BCP editing
- Drag operations for objects, anchor points, and control handles
- Multi-selection support

**Event Sourcing System:**
- Record all user interactions with 50ms sampling
- Store events in SQLite database
- Create periodic snapshots (every 1000 events)
- Replay events to reconstruct document state
- Support infinite undo/redo through event navigation

**File Operations:**
- Save documents to .wiretuner format (SQLite container)
- Load documents with event replay
- Version compatibility handling
- Export to SVG and PDF formats
- Import from Adobe Illustrator (.ai) files

**Canvas & Rendering:**
- CustomPainter-based rendering system
- Viewport transformation (pan, zoom)
- Path rendering with cubic Bezier curves
- Shape rendering (filled and stroked)
- Selection visualization (bounding boxes, handles)

<!-- anchor: non-functional-requirements -->
### 2.2. Non-Functional Requirements (NFRs)

<!-- anchor: nfr-performance -->
#### Performance
- **Target**: 60 FPS rendering during pan/zoom operations
- **Rationale**: Professional tools require fluid interaction for good UX
- **Impact**: Drives use of Flutter's CustomPainter and efficient rendering pipeline
- **Measurement**: Frame time monitoring, profiler analysis

<!-- anchor: nfr-scalability -->
#### Scalability
- **Target**: Support documents with 10,000+ objects without degradation
- **Rationale**: Professional workflows create complex illustrations
- **Impact**: Requires efficient data structures, spatial indexing, and viewport culling
- **Measurement**: Stress testing with large documents, rendering benchmarks

<!-- anchor: nfr-reliability -->
#### Reliability
- **Target**: Zero data loss, corruption-resistant file format
- **Rationale**: Professional work cannot be lost due to crashes
- **Impact**: Event sourcing provides natural audit trail, SQLite ACID guarantees
- **Measurement**: Crash recovery testing, file corruption resistance tests

<!-- anchor: nfr-maintainability -->
#### Maintainability
- **Target**: Modular architecture with clear separation of concerns
- **Rationale**: Single developer must maintain codebase long-term
- **Impact**: Drives layered architecture, immutable data patterns, comprehensive testing
- **Measurement**: Code review, test coverage (target: 80%+ for core logic)

<!-- anchor: nfr-usability -->
#### Usability
- **Target**: Intuitive UI matching conventions of Adobe Illustrator/Sketch
- **Rationale**: Lower learning curve for professional users
- **Impact**: Tool design, keyboard shortcuts, visual feedback patterns
- **Measurement**: Manual usability testing, comparison with reference tools

<!-- anchor: nfr-portability -->
#### Portability
- **Target**: Run natively on macOS and Windows with consistent behavior
- **Rationale**: Multi-platform distribution expands user base
- **Impact**: Flutter provides abstraction, but platform-specific testing required
- **Measurement**: Platform-specific test suite execution

<!-- anchor: constraints-preferences -->
### 2.3. Constraints & Preferences

<!-- anchor: constraint-technology -->
#### Technology Constraints
- **Flutter Framework**: Required for cross-platform desktop development
  - **Justification**: Enables single codebase for macOS/Windows, mature CustomPainter API
  - **Trade-off**: Larger binary size vs. native development, but acceptable for desktop

- **SQLite Database**: Required for event log and snapshot storage
  - **Justification**: Embedded, zero-configuration, ACID-compliant, portable file format
  - **Trade-off**: Not suitable for concurrent access, but single-user focus makes this acceptable

- **Dart Language**: Mandated by Flutter framework
  - **Justification**: Strong typing, null safety, good performance for UI applications
  - **Trade-off**: Smaller ecosystem than JavaScript/Python, but adequate for desktop apps

<!-- anchor: constraint-organizational -->
#### Organizational Constraints
- **Single Developer**: All implementation by one person
  - **Impact**: Architecture must be comprehensible, well-documented, testable
  - **Mitigation**: Clear ticket structure, comprehensive architecture docs, automated testing

- **Timeline**: Milestone 0.1 target ~21 days (4 weeks)
  - **Impact**: Scope limited to essential features, no gold-plating
  - **Mitigation**: Strict prioritization, critical path focus, defer nice-to-haves

<!-- anchor: constraint-architectural -->
#### Architectural Preferences
- **Event Sourcing**: Strong preference for event-sourced architecture
  - **Justification**: Enables undo/redo, collaboration future-proofing, audit trail
  - **Trade-off**: Increased complexity vs. traditional state management, but benefits outweigh costs

- **Immutable Data**: Preference for immutable data patterns
  - **Justification**: Predictable state changes, easier debugging, thread-safe
  - **Trade-off**: Memory overhead from copying, but manageable with efficient structures

- **Test Coverage**: Preference for comprehensive testing
  - **Justification**: Single developer needs confidence in refactoring, regression prevention
  - **Target**: 80%+ coverage for core logic (models, services), widget tests for UI

<!-- anchor: constraint-compatibility -->
#### Compatibility Requirements
- **File Format Versioning**: Must handle format evolution gracefully
  - **Approach**: Version field in SQLite schema, migration logic for loading older files

- **Import/Export Standards**: Must adhere to SVG 1.1, PDF 1.7, AI format specifications
  - **Approach**: Use established libraries (pdf, svg packages), reference Adobe AI spec
