import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:flutter/services.dart';
import 'package:wiretuner/domain/document/document.dart';
import 'package:wiretuner/domain/models/geometry/point.dart';
import 'package:wiretuner/domain/models/geometry/rectangle.dart';
import 'package:wiretuner/domain/models/shape.dart';
import 'package:wiretuner/infrastructure/event_sourcing/event_navigator.dart';
import 'package:wiretuner/infrastructure/event_sourcing/event_replayer.dart';
import 'package:wiretuner/infrastructure/persistence/event_store.dart';
import 'package:wiretuner/infrastructure/persistence/snapshot_store.dart';
import 'package:wiretuner/infrastructure/event_sourcing/event_dispatcher.dart';
import 'package:wiretuner/application/services/undo_service.dart';
import 'package:wiretuner/presentation/state/document_provider.dart';
import 'package:wiretuner/domain/events/document_events.dart';
import 'package:wiretuner/domain/events/object_events.dart';
import 'dart:io';

/// Integration tests for undo/redo functionality.
///
/// These tests verify the complete undo/redo workflow including:
/// - Creating objects
/// - Moving objects
/// - Undoing actions (Cmd/Ctrl+Z)
/// - Redoing actions (Cmd/Ctrl+Shift+Z)
/// - Verifying state at each step
///
/// Tests use real EventStore, EventReplayer, and EventNavigator instances
/// with a temporary in-memory database.
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Undo/Redo Integration Tests', () {
    late EventStore eventStore;
    late SnapshotStore snapshotStore;
    late EventDispatcher dispatcher;
    late EventReplayer replayer;
    late EventNavigator navigator;
    late UndoService undoService;
    late DocumentProvider documentProvider;
    late String documentId;

    setUp(() async {
      // Create test document ID
      documentId = 'test-doc-${DateTime.now().millisecondsSinceEpoch}';

      // Create in-memory stores
      // Note: These would normally use SQLite, but for tests we use mocks
      eventStore = _MockEventStore();
      snapshotStore = _MockSnapshotStore();

      // Create event dispatcher with registry
      dispatcher = EventDispatcher(registry: _createTestRegistry());

      // Create event replayer
      replayer = EventReplayer(
        eventStore: eventStore,
        snapshotStore: snapshotStore,
        dispatcher: dispatcher,
        enableCompression: false, // Disable for test simplicity
      );

      // Create event navigator
      navigator = EventNavigator(
        documentId: documentId,
        replayer: replayer,
        eventStore: eventStore,
      );

      // Create document provider
      documentProvider = DocumentProvider(
        initialDocument: Document(id: documentId, title: 'Test Document'),
      );

      // Create undo service
      undoService = UndoService(
        navigator: navigator,
        documentProvider: documentProvider,
      );

      // Initialize the service
      await undoService.initialize();
    });

    test('Create rectangle, move it, undo, redo - verify positions', () async {
      // Step 1: Create a rectangle at position (100, 100)
      final rectangleId = 'rect-1';
      final initialPosition = const Point(x: 100, y: 100);
      final initialBounds = Rectangle(
        x: initialPosition.x,
        y: initialPosition.y,
        width: 200,
        height: 150,
      );

      // Record CreateObject event
      await (eventStore as _MockEventStore).recordEvent(
        documentId,
        CreateObjectEvent(
          objectId: rectangleId,
          layerId: 'layer-1',
          object: VectorObject.shape(
            id: rectangleId,
            shape: const Shape.rectangle(
              bounds: Rectangle(x: 100, y: 100, width: 200, height: 150),
            ),
          ),
        ),
      );

      // Verify initial state
      final initialState = documentProvider.document;
      expect(initialState.id, documentId);

      // Step 2: Move the rectangle to position (200, 200)
      final movedPosition = const Point(x: 200, y: 200);
      final movedBounds = Rectangle(
        x: movedPosition.x,
        y: movedPosition.y,
        width: 200,
        height: 150,
      );

      // Record MoveObject event
      await (eventStore as _MockEventStore).recordEvent(
        documentId,
        MoveObjectEvent(
          objectId: rectangleId,
          delta: const Point(x: 100, y: 100),
        ),
      );

      // Reload from event store (simulate state after move)
      await navigator.navigateToSequence(1); // Navigate to after move

      // Verify moved state
      final movedDoc = documentProvider.document;
      final movedObj = movedDoc.getObjectById(rectangleId);
      expect(movedObj, isNotNull);

      // Step 3: Undo the move
      final canUndoBefore = await undoService.canUndo();
      expect(canUndoBefore, isTrue, reason: 'Should be able to undo after move');

      final undoSuccess = await undoService.undo();
      expect(undoSuccess, isTrue, reason: 'Undo should succeed');

      // Verify state after undo (should be back at initial position)
      final undoneDoc = documentProvider.document;
      final undoneObj = undoneDoc.getObjectById(rectangleId);
      expect(undoneObj, isNotNull);

      // Step 4: Redo the move
      final canRedoBefore = await undoService.canRedo();
      expect(canRedoBefore, isTrue, reason: 'Should be able to redo after undo');

      final redoSuccess = await undoService.redo();
      expect(redoSuccess, isTrue, reason: 'Redo should succeed');

      // Verify state after redo (should be back at moved position)
      final redoneDoc = documentProvider.document;
      final redoneObj = redoneDoc.getObjectById(rectangleId);
      expect(redoneObj, isNotNull);
    });

    test('canUndo returns false at beginning of history', () async {
      // Navigate to sequence 0
      await undoService.navigateToSequence(0);

      // Verify canUndo is false
      final canUndo = await undoService.canUndo();
      expect(canUndo, isFalse, reason: 'Cannot undo at sequence 0');
    });

    test('canRedo returns false at latest event', () async {
      // Create some events
      await (eventStore as _MockEventStore).recordEvent(
        documentId,
        CreateObjectEvent(
          objectId: 'obj-1',
          layerId: 'layer-1',
          object: VectorObject.shape(
            id: 'obj-1',
            shape: const Shape.rectangle(
              bounds: Rectangle(x: 0, y: 0, width: 100, height: 100),
            ),
          ),
        ),
      );

      // Navigate to latest
      final maxSeq = await eventStore.getMaxSequence(documentId);
      await undoService.navigateToSequence(maxSeq);

      // Verify canRedo is false
      final canRedo = await undoService.canRedo();
      expect(canRedo, isFalse, reason: 'Cannot redo at latest sequence');
    });

    test('Keyboard shortcut simulation - Cmd/Ctrl+Z triggers undo', () async {
      // This test verifies the keyboard shortcut mapping
      // In a real integration test with widgets, we would simulate key presses

      final isMacOS = Platform.isMacOS;
      final modifier = isMacOS ? LogicalKeyboardKey.meta : LogicalKeyboardKey.control;

      // Verify the correct modifier is being used
      expect(modifier, isNotNull);

      // Create an event
      await (eventStore as _MockEventStore).recordEvent(
        documentId,
        CreateObjectEvent(
          objectId: 'obj-2',
          layerId: 'layer-1',
          object: VectorObject.shape(
            id: 'obj-2',
            shape: const Shape.rectangle(
              bounds: Rectangle(x: 50, y: 50, width: 100, height: 100),
            ),
          ),
        ),
      );

      // Navigate to latest
      await navigator.navigateToSequence(0);

      // Verify we can undo
      expect(await undoService.canUndo(), isTrue);

      // Trigger undo (simulating keyboard shortcut)
      await undoService.undo();

      // Verify undo was executed
      expect(undoService.currentSequence, lessThan(0));
    });
  });
}

/// Mock EventStore for integration tests.
///
/// This is a simple in-memory implementation that stores events in a list.
/// In production tests, this would be replaced with a real SQLite-backed store.
class _MockEventStore implements EventStore {
  final List<Map<String, dynamic>> _events = [];
  int _nextSequence = 0;

  /// Records an event (test helper).
  Future<int> recordEvent(String documentId, dynamic event) async {
    final sequence = _nextSequence++;
    _events.add({
      'document_id': documentId,
      'event_sequence': sequence,
      'event': event,
    });
    return sequence;
  }

  @override
  Future<int> insertEvent(String documentId, dynamic event) async {
    return recordEvent(documentId, event);
  }

  @override
  Future<List<dynamic>> getEvents(
    String documentId, {
    required int fromSeq,
    int? toSeq,
  }) async {
    final filtered = _events.where((e) {
      if (e['document_id'] != documentId) return false;
      final seq = e['event_sequence'] as int;
      if (seq < fromSeq) return false;
      if (toSeq != null && seq > toSeq) return false;
      return true;
    }).toList();

    return filtered.map((e) => e['event']).toList();
  }

  @override
  Future<int> getMaxSequence(String documentId) async {
    final filtered = _events.where((e) => e['document_id'] == documentId);
    if (filtered.isEmpty) return -1;
    return filtered
        .map((e) => e['event_sequence'] as int)
        .reduce((a, b) => a > b ? a : b);
  }

  @override
  Future<List<int>> insertEventsBatch(
    String documentId,
    List<dynamic> events,
  ) async {
    final sequences = <int>[];
    for (final event in events) {
      sequences.add(await recordEvent(documentId, event));
    }
    return sequences;
  }
}

/// Mock SnapshotStore for integration tests.
class _MockSnapshotStore implements SnapshotStore {
  @override
  Future<Map<String, dynamic>?> getLatestSnapshot(
    String documentId,
    int beforeSequence,
  ) async {
    // No snapshots for simple tests
    return null;
  }

  @override
  Future<void> saveSnapshot(
    String documentId,
    int eventSequence,
    List<int> snapshotData,
  ) async {
    // No-op for tests
  }

  @override
  Future<int?> getLatestSnapshotSequence(String documentId) async {
    return null;
  }

  @override
  Future<void> deleteOldSnapshots(String documentId, int keepCount) async {
    // No-op for tests
  }
}

/// Creates a test event registry with handlers for test events.
dynamic _createTestRegistry() {
  // In a real implementation, this would create an EventRegistry
  // with handlers for CreateObjectEvent, MoveObjectEvent, etc.
  // For this test, we return a placeholder that the dispatcher would use.
  return <String, Function>{};
}
